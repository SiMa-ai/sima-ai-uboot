//SPDX-License-Identifier: (GPL-2.0+ OR MIT)
/*
 * Copyright (c) 2022 Sima ai
 * Generated 07/17/2024 11:32:16 by root
 */

#include <linux/kernel.h>
#include <asm/arch/ddr_phy_debug.h>
#include <linux/types.h>

typedef struct phy_debug_strings_t_ {
    uint32_t value;
    char str[300];
} phy_debug_strings_t;

typedef struct firmware_phy_debug_strings_t_ {
    uint32_t size;
    phy_debug_strings_t *strings;
} firmware_phy_debug_strings_t;

static phy_debug_strings_t lpddr5_pmu_train_debug[] = {
    { .value=0x00000000, .str="PMU200: /\/ Exporting 2D eyes\n" },
    { .value=0x00010000, .str="PMU200: /\/ Exporting Channel A\n" },
    { .value=0x00020000, .str="PMU200: /\/ Exporting Channel B\n" },
    { .value=0x00030000, .str="PMU200: /\/ Exporting RX eyes\n" },
    { .value=0x00040000, .str="DfeMode = RxDfe0Static; b000\n" },
    { .value=0x00050000, .str="DfeMode = RxDfe1Static; b001\n" },
    { .value=0x00060000, .str="DfeMode = RxDfePerRankStatic; b01x\n" },
    { .value=0x00070000, .str="DfeMode = RxDfeHistoryOn; b10x\n" },
    { .value=0x00080001, .str="PMU: ERROR: Bad dfeMode: 0x%2x\n" },
    { .value=0x00090000, .str="PMU200: /\/ Exporting TX eyes\n" },
    { .value=0x000a0005, .str="num_of_ranks = %d,\nDfeMode = %d,\ndbyte_start = %d,\ndbyte_end = %d,\nlaneMask = 0x%03x,\n" },
    { .value=0x000b0008, .str="messgBlock->RX2D_Delay_Weight = %d,\n->RX2D_Voltage_Weight = %d,\n->TX2D_Delay_Weight = %d,\n->TX2D_Voltage_Weight = %d,\n->CsPresentChA = %d,\n->CsPresentChB = %d,\n""# MAX_DBYTES %d\n# MAX_DBYTES %d\ntwoD_Eye_t_lp54 eye[2][2][MAX_DBYTES][MAX_LANES] = {\n" },
    { .value=0x000c0004, .str="[%d][%d][%d][%d] = {\n\t\t{ /\/ data:\n" },
    { .value=0x000d0003, .str="\t\t\t{%4d,%4d}, /\/ %d\n" },
    { .value=0x000e0003, .str="\t\t}, /\/ end data\n/\/ center\n\t\t{\n\t\t.anchorDelay = %d,\n\t\t.optimalDelayOffset = %d,\n\t\t.voltage = %d\n\t\t}\n\t}, /\/ end eye\n" },
    { .value=0x000f0000, .str="};/\/ end eye array\n" },
    { .value=0x00100040, .str="PMU4: %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d\n" },
    { .value=0x00110000, .str="PMU4: " },
    { .value=0x00120001, .str="%3d " },
    { .value=0x00130000, .str="\n" },
    { .value=0x0014001f, .str="PMU4: %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d\n" },
    { .value=0x00150000, .str="PMU4: " },
    { .value=0x00160001, .str="%3d " },
    { .value=0x00170000, .str="\n" },
    { .value=0x00180005, .str="PMU4: -- DB%d L%d -- centers: anchor delay = %d, optimal delay offset = %d voltage = %d\n" },
    { .value=0x00190003, .str="PMU4: -------- 2D Read Scanning TG %d (CS 0x%x) Lanes 0x%03x --------\n" },
    { .value=0x001a0003, .str="PMU4: -------- 2D Write Scanning TG %d (CS 0x%x) Lanes 0x%03x --------\n" },
    { .value=0x001b0000, .str="PMU: ***** Assertion Error - terminating *****\n" },
    { .value=0x001c0001, .str="PMU1: enabled dbytes mask 0x%x \n" },
    { .value=0x001d0004, .str="PMU1: lp4SetPhyConf: lptr.chADbStart %u, lptr.chADbEnd %u, lptr.chBDbStart %u, lptr.chBDbEnd %u\n" },
    { .value=0x001e0003, .str="PMU1: lp4SetPhyConf: lptr.CaNDevs[%u][%u] = %u\n" },
    { .value=0x001f0004, .str="PMU1: lp4X8ModeRank returns %u for chan=%u, csn=%u, messgBlock->X8Mode=0x%x\n" },
    { .value=0x00200005, .str="PMU1 setDbi Reads Static delay 0x%x, Toggle delay 0x%x, Fast Toggle Delay 0x%x, Delta %d, rxDBI %d \n" },
    { .value=0x00210002, .str="PMU1: acsm_init: acsm_mode %04x mxrdlat %04x\n" },
    { .value=0x00220000, .str="PMU1: acsm RUN\n" },
    { .value=0x00230000, .str="PMU1: acsm RUN RESIDENT SEQUENCE\n" },
    { .value=0x00240000, .str="PMU: Error: Polling on ACSM done failed to complete in acsm_poll_done()...\n" },
    { .value=0x00250001, .str="PMU1: AcPipeEn set to %d .\n" },
    { .value=0x00260000, .str="PMU1: Beginning assert_CKE() \n" },
    { .value=0x00270000, .str="PMU1: deassert_CKE() \n" },
    { .value=0x00280003, .str="PMU3: get_cmd_dly max(%d ps, %d memclk) = %d\n" },
    { .value=0x00290004, .str="PMU3: %u psdly = %u DfiClks, %u memClks = %u DfiClks\n" },
    { .value=0x002a0002, .str="PMU0: Write CSR 0x%06x 0x%04x\n" },
    { .value=0x002b0002, .str="PMU0: hwt_init_ppgc_prbs(): Polynomial: %x, Deg: %d\n" },
    { .value=0x002c0003, .str="PMU1: switch_ck_mode SE_CK %d SE_WDQS %d SE_WCK  %d\n" },
    { .value=0x002d0002, .str="PMU1: write mr %d with 0x%x \n" },
    { .value=0x002e0000, .str="PMU1: Programming MR12 for upper mode x8 device\n" },
    { .value=0x002f0001, .str="PMU3: Written MRS to CS=0x%02x\n" },
    { .value=0x00300000, .str="PMU3: Entering Boot Freq Mode.\n" },
    { .value=0x00310007, .str="PMU5: Writing new TxImpedances and Slew rates:\nPMU5: TxImpedanceDIFF0T = 0x%x\nPMU5: TxImpedanceDIFF0C = 0x%x\nPMU5: TxImpedanceSE0 = 0x%x\nPMU5: TxImpedanceSE1 = 0x%x\nPMU5: TxSlewDIFF0C = 0x%x\nPMU5: TxSlewSE0 = 0x%x\nPMU5: TxSlewSE1 = 0x%x\n" },
    { .value=0x00320000, .str="PMU3: Exiting Boot Freq Mode.\n" },
    { .value=0x00330000, .str="PMU5: Restoring original TxImpedances and Slew rates:\n" },
    { .value=0x00340003, .str="PMU1: MR slowmo debug Mo:%d mrVal:0x%x m:%d \n" },
    { .value=0x00350002, .str="PMU3: Writing MR%d OP=%x\n" },
    { .value=0x00360000, .str="PMU1: Programming MR12 for upper mode x8 device\n" },
    { .value=0x00370000, .str="PMU1: dozq in slowmo/n" },
    { .value=0x00380001, .str="PMU3: Written MRS to CS=0x%02x\n" },
    { .value=0x00390000, .str="PMU3: Enable Channel A\n" },
    { .value=0x003a0000, .str="PMU3: Enable Channel B\n" },
    { .value=0x003b0000, .str="PMU3: Enable All Channels\n" },
    { .value=0x003c0002, .str="PMU1:save_mr MR: %d val: 0x%x\n" },
    { .value=0x003d0002, .str="PMU1:restore_mr MR: %d val: 0x%x\n" },
    { .value=0x003e0002, .str="PMU1:or_mr MR: %d val: 0x%x\n" },
    { .value=0x003f0002, .str="PMU1:and_mr MR: %d val: 0x%x\n" },
    { .value=0x00400002, .str="PMU1:set_mr MR: %d val: 0x%x\n" },
    { .value=0x00410004, .str="PMU1: LP train Ch A Dbyte Start %d - End %d \n LP train Ch B Dbyte Start %d - End %d \n" },
    { .value=0x00420007, .str="PMU4: Dbyte%d: RxReplicaPathPhase 0: %d, 1: %d, 2: %d, 3: %d, 4: %d RxReplicaLcdlPh1UI %d  \n" },
    { .value=0x00430000, .str="PMU: Error: Path Phase not found.\n" },
    { .value=0x00440005, .str="PMU1: phase: %d, phase Difference: %d, phase1ui: %d, phase1ui %d%%: %d \n" },
    { .value=0x00450001, .str="PMU1: PathPhase*2: %d \n" },
    { .value=0x00460005, .str="PMU1: phase: %d, phase Difference: %d, phase1ui: %d, phase1ui %d%%: %d \n" },
    { .value=0x00470000, .str="PMU: Error: Path Phase not found.\n" },
    { .value=0x00480001, .str="PMU1: lock_rxReplica in Ch A db: %d \n" },
    { .value=0x00490001, .str="PMU1: lock_rxReplica end of Ch A db: %d \n" },
    { .value=0x004a0001, .str="PMU1: lock_rxReplica in of Ch b db: %d \n" },
    { .value=0x004b0001, .str="PMU1: lock_rxReplica All bytes done db: %d \n" },
    { .value=0x004c0001, .str="PMU1: lock_pll_dll: DEBUG: pllbypass = %d\n" },
    { .value=0x004d0002, .str="PMU4: SaveLcdlSeed: Saving seed of dx = %x, seed of ac = %x\n" },
    { .value=0x004e0000, .str="PMU1: in phy_defaults()\n" },
    { .value=0x004f0003, .str="PMU2: getRankMaxRxen(): channel:%d maxDly 0x%x Tg %d\n" },
    { .value=0x00500003, .str="DEBUG: trained DFIMRL Rank %x Channel %d MRL %d\n" },
    { .value=0x00510000, .str="PMU4: Storing frequency change results to ACSM for 2 Pstate case\n" },
    { .value=0x00520002, .str="PMU4: Storing MR%d mrVal:0x%x\n" },
    { .value=0x00530005, .str="PMU4: Writing Pstate %d Rank %d Channel %d MR%d mrVal:0x%x\n" },
    { .value=0x00540000, .str="PMU4: Reading Trained MRS from first pstate\n" },
    { .value=0x00550004, .str="PMU4: Reading first Pstate Rank %d Channel %d MR%d mrVal:0x%x\n" },
    { .value=0x00560003, .str="PMU1: populates_acsm_mrw cs%d mrNum%d mrVal 0x%x \n" },
    { .value=0x00570000, .str="PMU1: populates_acsm_delay\n" },
    { .value=0x00580000, .str="PMU1: populates_acsm_nop\n" },
    { .value=0x00590002, .str="PMU1: p commit_acsm_psRam psRamAddr%d, startPtr%d\n" },
    { .value=0x005a0001, .str="PMU4: Writing current pstate results to PsRam, dccm startAddr 0x%x\n" },
    { .value=0x005b0003, .str="PMU1: Type %d subtype %d csr 0x%x\n" },
    { .value=0x005c0002, .str="PMU1: dma_readwrite16(%d,0x%x)\n" },
    { .value=0x005d0006, .str="PMU4: Storing MR%d mrVal:0x%x for cs %d and Channel %d psRamAddr 0x%x acsmAddr 0x%x\n" },
    { .value=0x005e0004, .str="PMU4:check mb CSR start 0x%x length %d. MR start 0x%x len %d\n" },
    { .value=0x005f0000, .str="PMU4: All trained results written to PS SRAM\n" },
    { .value=0x00600002, .str="PMU1: MR slowmo debug MR%d mrVal:0x%x\n" },
    { .value=0x00610002, .str="PMU3: Writing MR%d OP=%x\n" },
    { .value=0x00620000, .str="PMU3: LP5 MR16 is being written\n" },
    { .value=0x00630000, .str="PMU3: Entering CBT-M2, so insert NOPs\n" },
    { .value=0x00640000, .str="PMU3: LP4 MR13 is being written\n" },
    { .value=0x00650000, .str="PMU3: Keeping CKE high\n" },
    { .value=0x00660002, .str="PMU3: Written MR%u to CS=0x%02x\n" },
    { .value=0x00670003, .str="PMU1: DVFSC %d WECC %d x8 %d" },
    { .value=0x00680004, .str="PMU1: WTRCommandSpacing %d total Write Latency %d BLN %d TWTR %d\n" },
    { .value=0x00690004, .str="PMU1: WTRCommandSpacing %d total Write Latency %d BLN %d TWTR %d\n" },
    { .value=0x006a0000, .str="PMU200: /\/ Exporting 2D eyes\n" },
    { .value=0x006b0000, .str="PMU200: /\/ Exporting Channel A\n" },
    { .value=0x006c0000, .str="PMU200: /\/ Exporting Channel B\n" },
    { .value=0x006d0000, .str="PMU200: /\/ Exporting RX eyes\n" },
    { .value=0x006e0000, .str="DfeMode = RxDfe0Static; b000\n" },
    { .value=0x006f0000, .str="DfeMode = RxDfe1Static; b001\n" },
    { .value=0x00700000, .str="DfeMode = RxDfePerRankStatic; b01x\n" },
    { .value=0x00710000, .str="DfeMode = RxDfeHistoryOn; b10x\n" },
    { .value=0x00720001, .str="PMU: ERROR: Bad dfeMode: 0x%2x\n" },
    { .value=0x00730000, .str="PMU200: /\/ Exporting TX eyes\n" },
    { .value=0x00740005, .str="num_of_ranks = %d,\nDfeMode = %d,\ndbyte_start = %d,\ndbyte_end = %d,\nlaneMask = 0x%03x,\n" },
    { .value=0x00750008, .str="->RX2D_Delay_Weight = %d,\n->RX2D_Voltage_Weight = %d,\n->TX2D_Delay_Weight = %d,\n->TX2D_Voltage_Weight = %d,\n->CsPresentChA = %d,\n->CsPresentChB = %d,\n""# MAX_DBYTES %d\n# MAX_DBYTES %d\ntwoD_Eye_t_lp54 eye[2][2][MAX_DBYTES][MAX_LANES] = {\n" },
    { .value=0x00760004, .str="[%d][%d][%d][%d] = {\n\t\t{ /\/ data:\n" },
    { .value=0x00770003, .str="\t\t\t{%4d,%4d}, /\/ %d\n" },
    { .value=0x00780003, .str="\t\t}, /\/ end data\n/\/ center\n\t\t{\n\t\t.anchorDelay = %d,\n\t\t.optimalDelayOffset = %d,\n\t\t.voltage = %d\n\t\t}\n\t}, /\/ end eye\n" },
    { .value=0x00790000, .str="};/\/ end eye array\n" },
    { .value=0x007a0040, .str="PMU4: %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d\n" },
    { .value=0x007b0000, .str="PMU4: " },
    { .value=0x007c0001, .str="%3d " },
    { .value=0x007d0000, .str="\n" },
    { .value=0x007e001f, .str="PMU4: %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d %3d\n" },
    { .value=0x007f0000, .str="PMU4: " },
    { .value=0x00800001, .str="%3d " },
    { .value=0x00810000, .str="\n" },
    { .value=0x00820005, .str="PMU4: -- DB%d L%d -- centers: anchor delay = %d, optimal delay offset = %d voltage = %d\n" },
    { .value=0x00830003, .str="PMU4: -------- 2D Read Scanning TG %d (CS 0x%x) Lanes 0x%03x --------\n" },
    { .value=0x00840003, .str="PMU4: -------- 2D Write Scanning TG %d (CS 0x%x) Lanes 0x%03x --------\n" },
    { .value=0x00850000, .str="PMU3: pmu_2Dtrain()\n" },
    { .value=0x00860000, .str="PMU4: pmu_2Dtrain() - RX-C EYES\n" },
    { .value=0x00870000, .str="PMU4: pmu_2Dtrain() -RX-T EYES\n" },
    { .value=0x00880000, .str="PMU4: pmu_2Dtrain() -TX EYES\n" },
    { .value=0x00890001, .str="PMU4: pmu_2Dtrain() - COLLECTEYES%d\n" },
    { .value=0x008a0000, .str="PMU4: pmu_2Dtrain() - EXPORT COLLECTED EYES\n" },
    { .value=0x008b0000, .str="PMU4: pmu_2Dtrain() - PROCESS EYES\n" },
    { .value=0x008c0000, .str="PMU4: pmu_2Dtrain() - EXPORT PROCESSED EYES\n" },
    { .value=0x008d0000, .str="PMU4: pmu_2Dtrain() - WRITING TX TRAINED VALUES\n" },
    { .value=0x008e0000, .str="PMU4: pmu_2Dtrain() - WRITING RX TRAINED VALUES\n" },
    { .value=0x008f0000, .str="PMU4: pmu_2Dtrain() - ADJUSTING RX TRAINED VALUES\n" },
    { .value=0x00900002, .str="PMU4: EYE OPTIMIZATION rx/tx = %d ranks = %d\n" },
    { .value=0x00910004, .str="PMU6: RX Eye 2D Training [][][%d][%d] ranks = %d, dfeMode = 0x%2x\n" },
    { .value=0x00920001, .str="PMU: ERROR: Bad dfeMode: 0x%2x\n" },
    { .value=0x00930001, .str="PMU: ERROR: Bad dfeMode: 0x%2x\n" },
    { .value=0x00940000, .str="PMU4: (lpddr4) FIND SOME SORT OF OPTIMAL DELAY FOR ALL AND ATTACH TO EACH EYE\n" },
    { .value=0x00950000, .str="PMU4: (lpddr4) FIND INTERSECTION OF ALL INVOLVED EYES WITH DELAY ALIGNMENT\n" },
    { .value=0x00960000, .str="PMU4: (lpddr4) FIND BEST VREF FOR SINGLE INTERSECTED EYE\n" },
    { .value=0x00970002, .str="PMU4: compounded eye center: (%d,%d)\n" },
    { .value=0x00980002, .str="PMU4: Compounded eye solution: (%d,%d)\n" },
    { .value=0x00990000, .str="PMU4: (lpddr4) FIND OPTIMAL DELAY FOR EACH EYE GIVEN THE OPTIMAL COMMON VREF\n" },
    { .value=0x009a0005, .str="PMU4: [%d][%d][%d][%d] optimal delay = %d\n" },
    { .value=0x009b0002, .str="PMU4: (lpddr5 x16) compound all lanes and high/low dbytes; dbytes:%d lane:%d\n" },
    { .value=0x009c0002, .str="PMU4: (lpddr5 x16) Find optimal delays given common Vref odd/even dbytes; dbytes:%d lane:%d\n" },
    { .value=0x009d0003, .str="PMU: Error: Margins are zero. 2D Training Failed cs = %d, dbyte = %d, lane = %d\n" },
    { .value=0x009e0003, .str="PMU: Four Eye Optimization 2D Training Failed cs = %d, dbyte = %d, lane = %d\n" },
    { .value=0x009f0003, .str="PMU: 2D Training Failed for Weighted Mean cs = %d, dbyte = %d, lane = %d\n" },
    { .value=0x00a00003, .str="PMU: Error: 2D Training Failed. eye_optimal_delay_for_vref - cs = %d, dbyte = %d, lane = %d\n" },
    { .value=0x00a10003, .str="PMU: 2D Training Failed - largest_empty_circle - cs = %d, dbyte = %d, lane = %d\n" },
    { .value=0x00a20003, .str="PMU: Error: Training Failure: Eye width less than 12/64 - create_search_seeds - cs = %d, dbyte = %d, lane = %d\n" },
    { .value=0x00a30003, .str="PMU: Error: Training Failure: Eye failure at new offset - adjust_delay_for_eye_collapse - cs = %d, dbyte = %d, lane = %d\n" },
    { .value=0x00a40003, .str="C->coarse (%d) != T->coarse (%d) numUIs=%d\n" },
    { .value=0x00a50004, .str="oddCScore=%d, oddTScore=%d, evenCScore=%d, evenTScore=%d\n" },
    { .value=0x00a60005, .str="PMU3: DEBUG lp4SetCatrVref 1: cs=%d chan=%d mr12=%x vref=%d.%d%%\n" },
    { .value=0x00a70000, .str="PMU3: Set CA Vref for x8 LP4 device\n" },
    { .value=0x00a80000, .str="PMU3: Set CA Vref for x16 LP4 device\n" },
    { .value=0x00a90003, .str="PMU3: DEBUG lp4SetCatrVref 3: mr12 = %x send vref= %x to db=%d\n" },
    { .value=0x00aa0000, .str="PMU3: Start WCK toggling \n" },
    { .value=0x00ab0000, .str="PMU3: Stop WCK toggling \n" },
    { .value=0x00ac0000, .str="PMU3: Pulling down DMI\n" },
    { .value=0x00ad0001, .str="PMU3: Enable Async mode on DQ[6:0] and write %u on DQ[6:0]\n" },
    { .value=0x00ae0000, .str="PMU3: Pulling up DMI\n" },
    { .value=0x00af0000, .str="PMU3: Restore Async modes on DQ[6:0] to get readback data\n" },
    { .value=0x00b00001, .str="PMU4: CAA%d " },
    { .value=0x00b10001, .str="%02x" },
    { .value=0x00b20000, .str="\n" },
    { .value=0x00b30001, .str="PMU4: CAB%d " },
    { .value=0x00b40001, .str="%02x" },
    { .value=0x00b50000, .str="\n" },
    { .value=0x00b60000, .str="PMU3: CA bitmap in binary format is\n" },
    { .value=0x00b70001, .str="PMU3: CAA%d " },
    { .value=0x00b80001, .str="PMU3: CAB%d " },
    { .value=0x00b90001, .str="%x" },
    { .value=0x00ba0001, .str="%x" },
    { .value=0x00bb0001, .str="%x" },
    { .value=0x00bc0001, .str="%x" },
    { .value=0x00bd0000, .str=" " },
    { .value=0x00be0000, .str="\n" },
    { .value=0x00bf0000, .str="In phase : " },
    { .value=0x00c00001, .str="%x" },
    { .value=0x00c10001, .str="%x" },
    { .value=0x00c20001, .str="%x" },
    { .value=0x00c30001, .str="%x" },
    { .value=0x00c40000, .str=" " },
    { .value=0x00c50000, .str="\n" },
    { .value=0x00c60000, .str="PMU3: Loading LP4 CA training pattern sending ACSM sequence\n" },
    { .value=0x00c70001, .str="PMU3: Writing ACSM sequence @ address %d\n" },
    { .value=0x00c80005, .str="PMU3: Loading LEFT_EYE_PAT %d, %d, %d, %d @ %d\n" },
    { .value=0x00c90004, .str="PMU3: Loading IN_PHASE_PAT%d, %d, %d, %d\n" },
    { .value=0x00ca0004, .str="PMU3: Loading LEFT_EYE_ANTI %d, %d, %d, %d\n" },
    { .value=0x00cb0004, .str="PMU3: Loading IN_PHASE_ANTI%d, %d, %d, %d\n" },
    { .value=0x00cc0000, .str="PMU: Unexplained error during loading CA rising edge resident sequence\n" },
    { .value=0x00cd0000, .str="PMU3: Written all LP4 CA training ACSM sequences, printing addresses\n" },
    { .value=0x00ce0004, .str="PMU3: ca_acsm_seq_start_addr[%d] = %d      ca_acsm_seq_end_addr[%d] = %d\n" },
    { .value=0x00cf0000, .str="PMU3: Loading LP5 CA training pattern sending ACSM sequence for " },
    { .value=0x00d00000, .str="rising edge \n" },
    { .value=0x00d10001, .str="PMU3: Writing ACSM sequence @ address %d\n" },
    { .value=0x00d20005, .str="PMU3: Loading LEFT_EYE_PAT %d, %d, %d, %d @ %d\n" },
    { .value=0x00d30004, .str="PMU3: Loading IN_PHASE_PAT%d, %d, %d, %d\n" },
    { .value=0x00d40004, .str="PMU3: Loading LEFT_EYE_ANTI %d, %d, %d, %d\n" },
    { .value=0x00d50004, .str="PMU3: Loading IN_PHASE_ANTI%d, %d, %d, %d\n" },
    { .value=0x00d60000, .str="PMU: Unexplained error during loading CA rising edge resident sequence\n" },
    { .value=0x00d70000, .str="falling edge \n" },
    { .value=0x00d80001, .str="PMU3: Writing ACSM sequence @ address %d\n" },
    { .value=0x00d90004, .str="PMU3: Loading LEFT_EYE_PAT %d, %d, %d, %d\n" },
    { .value=0x00da0004, .str="PMU3: Loading IN_PHASE_PAT%d, %d, %d, %d\n" },
    { .value=0x00db0004, .str="PMU3: Loading LEFT_EYE_ANTI %d, %d, %d, %d\n" },
    { .value=0x00dc0004, .str="PMU3: Loading IN_PHASE_ANTI%d, %d, %d, %d\n" },
    { .value=0x00dd0000, .str="PMU: Unexplained error during loading CA falling edge resident sequence\n" },
    { .value=0x00de0000, .str="PMU3: Written all LP5 CA training ACSM sequences, printing addresses\n" },
    { .value=0x00df0004, .str="PMU3: ca_acsm_seq_start_addr[%d] = %d      ca_acsm_seq_end_addr[%d] = %d\n" },
    { .value=0x00e00001, .str="PMU3: Load resident ACSM seq to start WCK toggling at %u\n" },
    { .value=0x00e10001, .str="PMU3: ACSM seq to start WCK toggles end at %u\n" },
    { .value=0x00e20002, .str="PMU3: Exit CA training for channel = %u, cs = %u\n" },
    { .value=0x00e30000, .str="PMU3: LP5 CBT exit: Driving DQ[7] low\n" },
    { .value=0x00e40000, .str="PMU3: LP5 CBT exit: Pull down dmi[0]\n" },
    { .value=0x00e50000, .str="PMU3: LP5 CBT exit: Reset WCKEXTENSION\n" },
    { .value=0x00e60000, .str="PMU3: exitCAtrain_lp5\n" },
    { .value=0x00e70001, .str="PMU3: Non terminating rank 0x%x CBT entry\n" },
    { .value=0x00e80002, .str="PMU3: Writing MR%u OP=0x%x\n" },
    { .value=0x00e90002, .str="PMU3: Configure CS termination for NT rank %u in chan %u\n" },
    { .value=0x00ea0002, .str="PMU3: Enter LP5 CBT for: channel %u, rank %u\n" },
    { .value=0x00eb0003, .str="PMU3: csn = %u, t_csn=%u, nt_csn=%u\n" },
    { .value=0x00ec0003, .str="PMU3: csn = %u, t_csn=%u, nt_csn=%u\n" },
    { .value=0x00ed0000, .str="PMU3: LP5 CBT enter: Set WCKEXTENSION\n" },
    { .value=0x00ee0003, .str="PMU3: chan = %d, csn = %d, lptr.CaNDevs[chan][csn] = %d\n" },
    { .value=0x00ef0000, .str="PMU3: Send MR16 to turn on CA training\n" },
    { .value=0x00f00003, .str="PMU3: chan = %d, csn = %d, lptr.CaNDevs[chan][csn] = %d\n" },
    { .value=0x00f10001, .str="PMU3: Writing %u on dq[6:0]\n" },
    { .value=0x00f20002, .str="PMU3: Exit CA training for channel = %u, cs = %u\n" },
    { .value=0x00f30000, .str="PMU3: exitCAtrain_lp4\n" },
    { .value=0x00f40002, .str="PMU3: Disable termination for chan %u, rank %u\n" },
    { .value=0x00f50002, .str="PMU3: Enter CA train, chan = %u: cs 0x%x\n" },
    { .value=0x00f60003, .str="PMU3: csn = %u, t_csn=%u, nt_csn=%u\n" },
    { .value=0x00f70002, .str="Disabling termination for chan %u, rank %u\n" },
    { .value=0x00f80003, .str="PMU3: csn=%u, t_csn=%u, nt_csn=%u\n" },
    { .value=0x00f90002, .str="Disabling termination for chan %u, rank %u\n" },
    { .value=0x00fa0001, .str="PMU3: DEBUG LP4 CBT entry 3: Put dbyte %d in async mode\n" },
    { .value=0x00fb0000, .str="PMU3: DEBUG LP4 CBT entry: Send MR13 to turn on CA training\n" },
    { .value=0x00fc0003, .str="PMU3: DEBUG LP4 CBT entry 7: idx = %d vref = %x mr12 = %x \n" },
    { .value=0x00fd0002, .str="PMU3: CA training phase %d looking for pattern %x\n" },
    { .value=0x00fe0004, .str="PMU3: loading ca_acsm_seq_start_addr[%d] = %d      ca_acsm_seq_end_addr[%d] = %d\n" },
    { .value=0x00ff0003, .str="PMU3: db: %u, Swizzled data = 0x%x, deswizzled data = 0x%x\n" },
    { .value=0x01000006, .str="PMU3: Phase %d patter sent = 0x%x, db:%d CAreadbackA:0x%x Xo:%x result=0x%x\n" },
    { .value=0x01010000, .str="PMU10:Optimizing vref\n" },
    { .value=0x01020004, .str="PMU3:mr12:%2x cs:%d chan %d r:%4x\n" },
    { .value=0x01030002, .str="PMU4: CA Vref bitmap for rank%d chan%d : " },
    { .value=0x01040001, .str="%d" },
    { .value=0x01050000, .str="\n" },
    { .value=0x01060005, .str="PMU3: i:%2d bstr:%2d bsto:%2d st:%d r:%d\n" },
    { .value=0x01070002, .str="Failed to find sufficient CA Vref Passing Region for CS %d channel %d\n" },
    { .value=0x01080003, .str="PMU4: StartIdx:%2d EndIdx:%2d Result:%2d\n" },
    { .value=0x01090005, .str="PMU5: Found %d.%d%% MR12:%x for cs:%d chan %d\n" },
    { .value=0x010a0002, .str="PMU3: camap[0][%d] = %d   " },
    { .value=0x010b0002, .str="camap[1][%d] = %d\n" },
    { .value=0x010c0000, .str="PMU3: Writing LP5 cs_training_seq\n" },
    { .value=0x010d0001, .str="PMU3: Sending %u to DRAM\n" },
    { .value=0x010e0000, .str="PMU3: CSTrain_rdwr_lp5, Writing 0 with long CS\n" },
    { .value=0x010f0003, .str="PMU3: db:%d CSreadback:%x result=0x%x\n" },
    { .value=0x01100000, .str="PMU3: CSTrain_rdwr_lp5 Writing 1 with short CS\n" },
    { .value=0x01110003, .str="PMU3: db:%d CSreadback:%x result=0x%x\n" },
    { .value=0x01120003, .str="PMU5: Begin CS training for channel %u, rank %u, lane %u\n" },
    { .value=0x01130002, .str="PMU3: ACSM ptr for acsm_send_direct_cmd is 0x%x, TAS_FLG is 0x%x\n" },
    { .value=0x01140000, .str="PMU3: Align CA nominally with falling clock edge\n" },
    { .value=0x01150000, .str="PMU3: Checking CS Early or Late wrt CA\n" },
    { .value=0x01160000, .str="PMU: LP5 CS Training Error! CS is Late wrt CA! Unable to proceed further\n" },
    { .value=0x01170001, .str="PMU3: LP5 CS Training testing dly %d\n" },
    { .value=0x01180000, .str="PMU3: Reverting all delays back to reset value\n" },
    { .value=0x01190002, .str="PMU4: CS bitmap is\nPMU4: CS%d (CA[%u]) " },
    { .value=0x011a0001, .str="%02x" },
    { .value=0x011b0000, .str="\n" },
    { .value=0x011c0000, .str="PMU: CS Training Error: No 0->1 transition as bitmap is all 0s\n" },
    { .value=0x011d0001, .str="PMU4: At delay:%u, 0->1 transition occurred\n" },
    { .value=0x011e0002, .str="PMU4: CSBACKOFF = %u\nPMU4: Subtracting %u from the delay\n" },
    { .value=0x011f0000, .str="PMU3: Disable WCK ODT and NT DQ ODT for all channels\n" },
    { .value=0x01200001, .str="PMU3: In lp5_dram_cbt_cfg, skip_mrw = 0x%lx\n" },
    { .value=0x01210002, .str="PMU3: Start rising edge CA training for Channel %u, CS %u\n" },
    { .value=0x01220002, .str="PMU3: Start falling edge CA training for Channel %u, CS %u\n" },
    { .value=0x01230003, .str="PMU5: csdly determined from CS training of channel %u, CS %u is: %i\n" },
    { .value=0x01240000, .str="PMU3: Using normal clock without CS training\n" },
    { .value=0x01250000, .str="PMU3:Using delayed clock without CS training\n" },
    { .value=0x01260001, .str="PMU3: Training CA delays, testing dly %d\n" },
    { .value=0x01270003, .str="PMU3: Reset CA/CS/CK delays for cs = %u, chan %u, pstate 0x%x\n" },
    { .value=0x01280000, .str="CA TRAINING ERROR: MsgMisc[3] is 1 => Boot frequency clock is disabled. Reset to execute CA training " },
    { .value=0x01290000, .str="PMU3: CAtrain_lp\n" },
    { .value=0x012a0001, .str="PMU3: CAtrain Begins. CS = %u\n" },
    { .value=0x012b0002, .str="PMU4: Channel %u CA bitmap after rising edge CA training of rank %u is\n" },
    { .value=0x012c0002, .str="PMU4: Channel %u CA bitmap after falling edge CA training of rank %u is\n" },
    { .value=0x012d0002, .str="PMU5: Channel %u uses normal clock (offset = %u)\n" },
    { .value=0x012e0001, .str="PMU5: Channel %u uses delayed clock (offset = 1 MEMCLK), all CS/CA delay will add this offset\n" },
    { .value=0x012f0001, .str="PMU5: Channel %u uses delayed clock (offset = 1/4 MEMCLK), all CS/CA delay will add this offset\n" },
    { .value=0x01300002, .str="PMU3:chan = %d, num_of_channels = %d\n" },
    { .value=0x01310004, .str="PMU4: lane %u, valid range from min_dly:%d to max_dly:%d span:%d\n" },
    { .value=0x01320004, .str="PMU3: min_dly:%u, maxspan:%u, span:%u, last_min_dly:%u\n" },
    { .value=0x01330002, .str="PMU3: lane %u, before adjustment, delay calculated:%i\n" },
    { .value=0x01340002, .str="PMU3: Final delay calculated for lane %u is %i\n" },
    { .value=0x01350000, .str="\nPMU10: CA training - No Range found!\n" },
    { .value=0x01360003, .str="PMU5: Setting ACTxDly for channel %u, lane %u to %u\n" },
    { .value=0x01370002, .str="PMU5: Setting ACTxDly for CS1 of channel %u to %i\n" },
    { .value=0x01380004, .str="PMU5: Setting ACTxDly for CS2 of channel %u to %i\nPMU5: Setting CKTxDly for channel %u to %i\n" },
    { .value=0x01390000, .str="PMU: Error: CA Training Failed.\n" },
    { .value=0x013a0001, .str="PMU3: Inserting dcmm wait, memclks = %u \n" },
    { .value=0x013b0000, .str="PMU3: Set WCKEXTENSION\n" },
    { .value=0x013c0002, .str="PMU5: VID read as 0x%x from db %d\n" },
    { .value=0x013d0002, .str="PMU3: Chan %u, Rank %u is X16 device\n" },
    { .value=0x013e0002, .str="PMU3: acsm_load_dcm_measure_seq= %d      dcm_acsm_seq_end_addr= %d\n" },
    { .value=0x013f0004, .str="PMU3: DRAM DCA Training: Channel %u, rank %u, iteration %u, dca_val = %i\n" },
    { .value=0x01400002, .str="PMU3:MR26 read 0x%x from dbyte %d\n" },
    { .value=0x01410002, .str="PMU3:MR26 read 0x%x from dbyte %d\n" },
    { .value=0x01420004, .str="PMU3:DCMU1 = %u, DCMU0 = %u, DCML1 = %u, DCML0 = %u\n" },
    { .value=0x01430003, .str="PMU3: DB%u, flip0 = %u, flip1 = %u\n" },
    { .value=0x01440002, .str="PMU3: DB%u Flip0 transition observed @ dca = %i\n" },
    { .value=0x01450005, .str="PMU3: DCATransFlip0[%u][%u] %i, New nDCATransFlip0[%u] = %i\n" },
    { .value=0x01460002, .str="PMU3: DB%u Flip1 transition observed @ dca = %i\n" },
    { .value=0x01470005, .str="PMU3: DCATransFlip1[%u][%u] %i, New nDCATransFlip1[%u] = %i\n" },
    { .value=0x01480002, .str="PMU5: DCA result of channel %u, rank %u as read by sweeping MR30 is\n" },
    { .value=0x01490000, .str="PMU4: DCA val   -7 -6 -5 -4 -3 -2 -1  0  1  2  3  4  5  6  7\n" },
    { .value=0x014a0001, .str="PMU4: DB%u flip0" },
    { .value=0x014b000f, .str="%3u%3u%3u%3u%3u%3u%3u%3u%3u%3u%3u%3u%3u%3u%3u\n" },
    { .value=0x014c0001, .str="PMU4: DB%u flip1" },
    { .value=0x014d000f, .str="%3u%3u%3u%3u%3u%3u%3u%3u%3u%3u%3u%3u%3u%3u%3u\n" },
    { .value=0x014e0000, .str="PMU4: DCA val     " },
    { .value=0x014f0001, .str="%3i" },
    { .value=0x01500000, .str="\n" },
    { .value=0x01510001, .str="PMU5: DB%u flip0   " },
    { .value=0x01520001, .str="%3u" },
    { .value=0x01530000, .str="\n" },
    { .value=0x01540001, .str="PMU5: DB%u flip1   " },
    { .value=0x01550001, .str="%3u" },
    { .value=0x01560000, .str="\n" },
    { .value=0x01570007, .str="PMU3: %u Flip 0 transitions for DB%u, averaging DCATransFlip0[%u][0] = %i and DCATransFlip0[%u][%u] = %i\n" },
    { .value=0x01580007, .str="PMU3: %u Flip1 transitions for DB%u, averaging DCATransFlip1[%u][0] = %i and DCATransFlip1[%u][%u] = %i\n" },
    { .value=0x01590005, .str="PMU3: DB%u Compounded DCATransFlip0[%u] = %i, DCATransFlip1[%u] = %i\n" },
    { .value=0x015a0002, .str="PMU4: Rank %u, DCAUpper calculated as = %i\n" },
    { .value=0x015b0002, .str="PMU4: Rank %u, DCALower calculated as = %i\n" },
    { .value=0x015c0003, .str="PMU5: Setting MR30 for cs %d chan %d to 0x%x\n" },
    { .value=0x015d0000, .str="PMU3: Reset WCKEXTENSION\n" },
    { .value=0x015e0004, .str="PMU4: DB%u lane %u, Saving RxClkT = 0x%x, RxClkC = 0x%x\n" },
    { .value=0x015f0003, .str="PMU4: DB%u lane %u, Saving TxDqDly = 0x%x\n" },
    { .value=0x01600002, .str="PMU4: Restoring trained values of RxClkT, RxClkC, dfe %d, isTrainingLoopDisabled %d\n" },
    { .value=0x01610004, .str="PMU4: DB%u lane %u, restoring RxClkT = 0x%x, RxClkC = 0x%x\n" },
    { .value=0x01620000, .str="PMU4: Restoring trained values of TxDqDly and TxDqsDly\n" },
    { .value=0x01630003, .str="PMU4: DB%u lane %u, restoring TxDqDly = 0x%x\n" },
    { .value=0x01640000, .str="PMU4: average_out_phy_dca_delays function called\n" },
    { .value=0x01650003, .str="PMU4: rdwr_dca_dly [%d][%d]=%d\n" },
    { .value=0x01660002, .str="PMU4: PHY DCA delays min=%d max=%d \n" },
    { .value=0x01670002, .str="PMU4: PHY DCA VALUES avg pd = %d avg pu = %d \n" },
    { .value=0x01680004, .str="PMU4: In train_phy_dca, csn = %u, iterations = %u, doDBI = 0x%x, stage = %u\n" },
    { .value=0x01690002, .str="PMU4: CSR addresses, csr_t = 0x%x, csr_c = 0x%x\n" },
    { .value=0x016a0002, .str="PMU4: coarse_t = 0x%x, coarse_c = 0x%x\n" },
    { .value=0x016b0004, .str="PMU1: Iteration %u, pd = %u, pu = %u, coarse = %u\n" },
    { .value=0x016c0003, .str="PMU1: Starting data scan for %u, pd = %u, pu = %u\n" },
    { .value=0x016d0003, .str="PMU1: DB:%u, lane:%u, cur delay = %i\n" },
    { .value=0x016e0003, .str="PMU1: DB:%u, CSR2 lane:%u, cur delay = %i\n" },
    { .value=0x016f0004, .str="PMU1: DB:%u, iteration = %i, cumulative_dly = %u, cumulative_dly2 = %u\n" },
    { .value=0x01700006, .str="PMU1: DB:%u, iteration = %i, pd = %i, pu = %i, selecting min = %i with cumulative_dly = %u\n" },
    { .value=0x01710003, .str="PMU4: DB:%u, delay for DCA %u = %i\n" },
    { .value=0x01720003, .str="PMU4: DB:%u, programming pd DCA %u gives the max eye width in all lanes as %u\n" },
    { .value=0x01730003, .str="PMU4: DB:%u, read_write_dly %u rdwr_dca_dly_count = %u \n" },
    { .value=0x01740000, .str="\nPMU200: Running compound_and_optimize_4_eyes_hill_climb()\n" },
    { .value=0x01750001, .str="PMU200: seeds set %d\n" },
    { .value=0x01760001, .str="PMU200: delay_tg0 = %d\n" },
    { .value=0x01770001, .str="PMU200: delay_tg1 = %d\n" },
    { .value=0x01780001, .str="PMU200: vref0 = %d\n" },
    { .value=0x01790001, .str="PMU200: vref2 = %d\n" },
    { .value=0x017a0000, .str="\nPMU200: Create Edge Lists\n" },
    { .value=0x017b0001, .str="PMU200: (*e00).center.anchorDelay = %d\n" },
    { .value=0x017c0001, .str="PMU200: (*e20).center.anchorDelay = %d\n" },
    { .value=0x017d0001, .str="PMU200: (*e01).center.anchorDelay = %d\n" },
    { .value=0x017e0001, .str="PMU200: (*e21).center.anchorDelay = %d\n" },
    { .value=0x017f0000, .str="PMU200: New anchorDelays:\n" },
    { .value=0x01800001, .str="PMU200: (*e00).center.anchorDelay = %d\n" },
    { .value=0x01810001, .str="PMU200: (*e20).center.anchorDelay = %d\n" },
    { .value=0x01820001, .str="PMU200: (*e01).center.anchorDelay = %d\n" },
    { .value=0x01830001, .str="PMU200: (*e21).center.anchorDelay = %d\n" },
    { .value=0x01840001, .str="PMU200: anchorDelay_offset_00 = %d\n" },
    { .value=0x01850001, .str="PMU200: anchorDelay_offset_20 = %d\n" },
    { .value=0x01860001, .str="PMU200: anchorDelay_offset_01 = %d\n" },
    { .value=0x01870001, .str="PMU200: anchorDelay_offset_21 = %d\n" },
    { .value=0x01880000, .str="\nPMU200: Iterate Over Seeds\n" },
    { .value=0x01890001, .str="\nPMU200: Explore Seed Set: %d\n" },
    { .value=0x018a0004, .str="PMU200: (margin_eye00,margin_eye01,margin_eye20,margin_eye21) = (%d,%d,%d,%d)\n" },
    { .value=0x018b0000, .str="PMU200: Terminating exploration of seed set due to one margin being zero.\n" },
    { .value=0x018c0003, .str="PMU200: initial t=%d delay0 = %d delay1 = %d\n" },
    { .value=0x018d0001, .str="PMU200: vref0 = %d\n" },
    { .value=0x018e0001, .str="PMU200: vref2 = %d\n" },
    { .value=0x018f0004, .str="PMU200: margin = 0x%08x %08x %08x %08x\n" },
    { .value=0x01900004, .str="PMU200: %d t=%d delay0 = %d delay1 = %d\n" },
    { .value=0x01910001, .str="PMU200: vref0 = %d\n" },
    { .value=0x01920001, .str="PMU200: vref2 = %d\n" },
    { .value=0x01930004, .str="PMU200: last_margin = 0x%08x %08x %08x %08x\n" },
    { .value=0x01940004, .str="PMU200: current_margin = 0x%08x %08x %08x %08x\n" },
    { .value=0x01950000, .str="PMU4: compound_and_optimize_four_eyes() STEP 1\n" },
    { .value=0x01960000, .str="PMU4: compound_and_optimize_four_eyes() STEP 2\n" },
    { .value=0x01970000, .str="PMU4: compound_and_optimize_four_eyes() STEP 3\n" },
    { .value=0x01980002, .str="PMU200: compound_2_eyes() x_offset=%d, y_offset=%d\n" },
    { .value=0x01990002, .str="PMU4: mass_sum = 0 momentx_sum = %d, momenty_sum = %d\n" },
    { .value=0x019a0000, .str="PMU4: no eye opening\n" },
    { .value=0x019b0004, .str="\nPMU200: Running hill_climb_2d() with seed (%d,%d) weights: voltage^2=%d delay^2=%d\n" },
    { .value=0x019c0003, .str="PMU200: Initial point: (%d,%d) cost: %d\n" },
    { .value=0x019d0006, .str="PMU200: %d point: (%d,%d) cost: %d, temp:%d, count_down = %d\n" },
    { .value=0x019e0003, .str="PMU201 Left Edge of Eye at delay: %d, Right Edge: %d, Width: %d\n" },
    { .value=0x019f0003, .str="Error:Failed to find Si Friendly Offset offset for cs %d dbyte %d lane %d\n" },
    { .value=0x01a00003, .str="PMU200: adjust_delay_for_eye_collapse() new point is outside eye: Vdef = %d, delay = %d, offset = %d\n" },
    { .value=0x01a10001, .str="PMU4: msgblock margin A: %d\n" },
    { .value=0x01a20001, .str="PMU4: msgblock margin B: %d\n" },
    { .value=0x01a30003, .str="PMU3: data_scan_acsm_seq pattern = %d, start addr = %d, stop_addr = %d\n" },
    { .value=0x01a40001, .str="PMU Error: Invalid Training Pattern Enum Selected %d.\n" },
    { .value=0x01a50000, .str="Swizzle not enabled when trying to enable dbi inverts.\n" },
    { .value=0x01a60001, .str="PMU1: RdWrInvert 0x%x" },
    { .value=0x01a70003, .str="PMU1: **** data_scan_init trainingCsr(read type) %d pattern %d, cs %d\n" },
    { .value=0x01a80001, .str="PMU: Error: Invalid Training CSR %d specified in training.\n" },
    { .value=0x01a90005, .str="pmu1: InternalStatus 0x%x, pattern enum 0x%x, delay step size %d, use trained data %d, use4uiscan %d\n" },
    { .value=0x01aa0005, .str="PMU4: Data Collection iterations 0x%x trainingCsr %d traininPatternEnum %d doDBI %d vrefStepSize %d\n" },
    { .value=0x01ab0000, .str="PMU: Error: Invalid VREF CSR \n" },
    { .value=0x01ac0002, .str="PMU2: DB:%i, lane:%i: " },
    { .value=0x01ad0005, .str="PMU2: left = %i, right = %i, lastLeft = %i, lastRight = %i, delayStepSize = %i\n" },
    { .value=0x01ae0005, .str="PMU2: left = %i, right = %i, lastLeft = %i, lastRight = %i, delayStepSize = %i\n" },
    { .value=0x01af0001, .str="PMU2:anchorDelay = %i\n" },
    { .value=0x01b00001, .str="pmu1: internalTrainingStage 0x%x \n" },
    { .value=0x01b10006, .str="PMU: Error: Invalid eye width in 1D scan eye is less than 6 delay steps wide, actual width is %d for Dbyte:%d, Lane: %d, Rank: %d,DFE: %d specified in read or write training stage %d.\n" },
    { .value=0x01b20006, .str="PMU1: 2D eye DFE %d, cs %d, db %d, Lane %d, center %d, left edge %d \n" },
    { .value=0x01b30000, .str="PMU1: read scanning Top of eye " },
    { .value=0x01b40001, .str=" %3d" },
    { .value=0x01b50000, .str="\nPMU1: read scanning Bot of eye " },
    { .value=0x01b60001, .str=" %3d" },
    { .value=0x01b70000, .str="\n" },
    { .value=0x01b80005, .str="PMU3: ****read Scanning passing region Left %d/64 Right %d/64, eyeCenter %d/64 , startDelay %d Fine, anchor delay %d \n" },
    { .value=0x01b90007, .str="PMU1: start %d stop %d  step %d ad %d fixed %d rptr%d to %d \n" },
    { .value=0x01ba0004, .str="PMU4: Vref start %d stop %d step %d dac %d\n" },
    { .value=0x01bb0006, .str="PMU1: **** read Scanning pattern enum %d read type %d numTransactions %d scan64 %d startDly 0x%x doDBI %d****\n" },
    { .value=0x01bc0003, .str="PMU1: doDBI=%x mxRdLat training pstate %d, do DBI Pattern %d\n" },
    { .value=0x01bd0001, .str="PMU1: mxRdLat search for cs %d\n" },
    { .value=0x01be0003, .str="PMU4: CS %d Dbyte %d worked with DFIMRL = %d DFICLKs \n" },
    { .value=0x01bf0003, .str="PMU3: MaxRdLat Read Lane err mask for csn %d DFIMRL %2d, All dbytes = 0x%03x\n" },
    { .value=0x01c00002, .str="PMU3: Found DFIMRL for channel a of cs %d, DFIMRL=%d\n" },
    { .value=0x01c10002, .str="PMU3: Found DFIMRL for channel b of cs %d, DFIMRL=%d\n" },
    { .value=0x01c20002, .str="PMU3: Found DFIMRL for all channel of cs %d, DFIMRL=%d\n" },
    { .value=0x01c30001, .str="PMU: Error: CS%d failed to find a DFIMRL setting that worked for all bytes during MaxRdLat training\n" },
    { .value=0x01c40002, .str="PMU3: Smallest passing DFIMRL for all dbytes in CS%d = %d DFIClks\n" },
    { .value=0x01c50000, .str="PMU: Error: No passing DFIMRL value found for any chip select during MaxRdLat training\n" },
    { .value=0x01c60001, .str="PMU1 eye before shift <TOP  Bottom>  shift %d \n" },
    { .value=0x01c70001, .str=" %3d" },
    { .value=0x01c80000, .str="\n" },
    { .value=0x01c90001, .str=" %3d" },
    { .value=0x01ca0000, .str="\n" },
    { .value=0x01cb0000, .str="PMU1 eye after shift <TOP  Bottom> \n" },
    { .value=0x01cc0001, .str=" %3d" },
    { .value=0x01cd0000, .str="\n" },
    { .value=0x01ce0001, .str=" %3d" },
    { .value=0x01cf0000, .str="\n" },
    { .value=0x01d00006, .str="PMU1: eye cs %d db %d lane %d raw delay %d raw vref0 %d vref1 %d \n" },
    { .value=0x01d10004, .str="PMU1: eye cs %d db %d lane %d raw delay %d\n" },
    { .value=0x01d20003, .str="\n cs %d, db %d, lane %d: " },
    { .value=0x01d30008, .str="PMU1: DB%dL%d; PPT2 debug savedResult %d, startDelayFine %d, leftEdge %d, rightEdge %d, left %d, right %d \n" },
    { .value=0x01d40004, .str="PMU1: PPT2 csrLeft %d, left %d, csrRight %d, right %d\n" },
    { .value=0x01d50004, .str="PMU1: PPT2 Results csrIndex %d, value %d, left %d, right %d\n" },
    { .value=0x01d6001d, .str="PMU10: 01=%02X 02=%02X 03=%02X 10=%02X\nPMU10: 11=%02X 12=%02X 13=%02X 14=%02X\nPMU10: 15=%02X 16=%02X 17=%02X 18=%02X\nPMU10: 19=%02X 20=%02X 21=%02X 22=%02X\nPMU10: 24=%02X 25=%02X 26=%02X 27=%02X\nPMU10: 28=%02X 30=%02X 31=%02X 32=%02X\nPMU10: 33=%02X 34=%02X 37=%02X 40=%02X\nPMU10: 41=%02X\n" },
    { .value=0x01d7001d, .str="PMU10: 01=%02X 02=%02X 03=%02X 10=%02X\nPMU10: 11=%02X 12=%02X 13=%02X 14=%02X\nPMU10: 15=%02X 16=%02X 17=%02X 18=%02X\nPMU10: 19=%02X 20=%02X 21=%02X 22=%02X\nPMU10: 24=%02X 25=%02X 26=%02X 27=%02X\nPMU10: 28=%02X 30=%02X 31=%02X 32=%02X\nPMU10: 33=%02X 34=%02X 37=%02X 40=%02X\nPMU10: 41=%02X\n" },
    { .value=0x01d8001d, .str="PMU10: 01=%02X 02=%02X 03=%02X 10=%02X\nPMU10: 11=%02X 12=%02X 13=%02X 14=%02X\nPMU10: 15=%02X 16=%02X 17=%02X 18=%02X\nPMU10: 19=%02X 20=%02X 21=%02X 22=%02X\nPMU10: 24=%02X 25=%02X 26=%02X 27=%02X\nPMU10: 28=%02X 30=%02X 31=%02X 32=%02X\nPMU10: 33=%02X 34=%02X 37=%02X 40=%02X\nPMU10: 41=%02X\n" },
    { .value=0x01d9001d, .str="PMU10: 01=%02X 02=%02X 03=%02X 10=%02X\nPMU10: 11=%02X 12=%02X 13=%02X 14=%02X\nPMU10: 15=%02X 16=%02X 17=%02X 18=%02X\nPMU10: 19=%02X 20=%02X 21=%02X 22=%02X\nPMU10: 24=%02X 25=%02X 26=%02X 27=%02X\nPMU10: 28=%02X 30=%02X 31=%02X 32=%02X\nPMU10: 33=%02X 34=%02X 37=%02X 40=%02X\nPMU10: 41=%02X\n" },
    { .value=0x01da001d, .str="PMU10: 01=%02X 02=%02X 03=%02X 10=%02X\nPMU10: 11=%02X 12=%02X 13=%02X 14=%02X\nPMU10: 15=%02X 16=%02X 17=%02X 18=%02X\nPMU10: 19=%02X 20=%02X 21=%02X 22=%02X\nPMU10: 24=%02X 25=%02X 26=%02X 27=%02X\nPMU10: 28=%02X 30=%02X 31=%02X 32=%02X\nPMU10: 33=%02X 34=%02X 37=%02X 40=%02X\nPMU10: 41=%02X\n" },
    { .value=0x01db001d, .str="PMU10: 01=%02X 02=%02X 03=%02X 10=%02X\nPMU10: 11=%02X 12=%02X 13=%02X 14=%02X\nPMU10: 15=%02X 16=%02X 17=%02X 18=%02X\nPMU10: 19=%02X 20=%02X 21=%02X 22=%02X\nPMU10: 24=%02X 25=%02X 26=%02X 27=%02X\nPMU10: 28=%02X 30=%02X 31=%02X 32=%02X\nPMU10: 33=%02X 34=%02X 37=%02X 40=%02X\nPMU10: 41=%02X\n" },
    { .value=0x01dc001d, .str="PMU10: 01=%02X 02=%02X 03=%02X 10=%02X\nPMU10: 11=%02X 12=%02X 13=%02X 14=%02X\nPMU10: 15=%02X 16=%02X 17=%02X 18=%02X\nPMU10: 19=%02X 20=%02X 21=%02X 22=%02X\nPMU10: 24=%02X 25=%02X 26=%02X 27=%02X\nPMU10: 28=%02X 30=%02X 31=%02X 32=%02X\nPMU10: 33=%02X 34=%02X 37=%02X 40=%02X\nPMU10: 41=%02X\n" },
    { .value=0x01dd001d, .str="PMU10: 01=%02X 02=%02X 03=%02X 10=%02X\nPMU10: 11=%02X 12=%02X 13=%02X 14=%02X\nPMU10: 15=%02X 16=%02X 17=%02X 18=%02X\nPMU10: 19=%02X 20=%02X 21=%02X 22=%02X\nPMU10: 24=%02X 25=%02X 26=%02X 27=%02X\nPMU10: 28=%02X 30=%02X 31=%02X 32=%02X\nPMU10: 33=%02X 34=%02X 37=%02X 40=%02X\nPMU10: 41=%02X\n" },
    { .value=0x01de0002, .str="PMU10: PHY TOTALS - NUM_DBYTES %d NUM_NIBBLES %d \n" },
    { .value=0x01df0006, .str="PMU10: CSA=0x%02X, CSB=0x%02X, TSTAGES=0x%04X, HDTOUT=%d, MMISC=%d DRAMFreq=%dMT DramType=LPDDR4\n" },
    { .value=0x01e00006, .str="PMU10: CSA=0x%02X, CSB=0x%02X, TSTAGES=0x%04X, HDTOUT=%d, MMISC=%d DRAMFreq=%dMT DramType=LPDDR5\n" },
    { .value=0x01e10005, .str="PMU10: Pstate%d MRS MR01_A0=0x%02X MR02_A0=0x%02X MR03_A0=0x%02X MR11_A0=0x%02X\n" },
    { .value=0x01e20005, .str="PMU10: Pstate%d MRS MR12_A0=0x%02X MR13_A0=0x%02X MR14_A0=0x%02X MR22_A0=0x%02X\n" },
    { .value=0x01e30005, .str="PMU10: Pstate%d MRS MR01_A1=0x%02X MR02_A1=0x%02X MR03_A1=0x%02X MR11_A1=0x%02X\n" },
    { .value=0x01e40005, .str="PMU10: Pstate%d MRS MR12_A1=0x%02X MR13_A1=0x%02X MR14_A1=0x%02X MR22_A1=0x%02X\n" },
    { .value=0x01e50005, .str="PMU10: Pstate%d MRS MR01_B0=0x%02X MR02_B0=0x%02X MR03_B0=0x%02X MR11_B0=0x%02X\n" },
    { .value=0x01e60005, .str="PMU10: Pstate%d MRS MR12_B0=0x%02X MR13_B0=0x%02X MR14_B0=0x%02X MR22_B0=0x%02X\n" },
    { .value=0x01e70005, .str="PMU10: Pstate%d MRS MR01_B1=0x%02X MR02_B1=0x%02X MR03_B1=0x%02X MR11_B1=0x%02X\n" },
    { .value=0x01e80005, .str="PMU10: Pstate%d MRS MR12_B1=0x%02X MR13_B1=0x%02X MR14_B1=0x%02X MR22_B1=0x%02X\n" },
    { .value=0x01e90001, .str="PMU10: Pstate%d \n" },
    { .value=0x01ea000b, .str="PMU4: PllCtrl1=0x%04x PllCpIntCtrl=0x%02x PllCpPropCtrl=0x%02x\nPMU4: PllCtrl4=0x%04x PllCpIntGsCtrl=0x%02x PllCpPropGsCtrl=0x%02x\nPMU4: PllCtrl5=0x%04x\nPMU4: PllUPllProg0=0x%04x PllUPllProg1=0x%04x PllUPllProg2=0x%04x PllUPllProg3=0x%04x\n" },
    { .value=0x01eb0001, .str="PMU4: DfiFreqRatio is %d\n" },
    { .value=0x01ec0000, .str="PMU5: LP5Mode CSR Programmed to LP4\n" },
    { .value=0x01ed0001, .str="PMU4: DfiFreqRatio is %d\n" },
    { .value=0x01ee0000, .str="PMU5: LP5Mode CSR Programmed to LP5\n" },
    { .value=0x01ef0000, .str="PMU3: writeRxenAcsm()\n" },
    { .value=0x01f00000, .str="PMU3: writeRxenAcsm()\n" },
    { .value=0x01f10002, .str="PMU1: In rxenb_train() csn=%d pstate=%d\n" },
    { .value=0x01f20000, .str="PMU4: Finding DQS falling edge\n" },
    { .value=0x01f30000, .str="PMU4: Searching for  read preamble\n" },
    { .value=0x01f40004, .str="PMU4: dtsm failed Bytes : %2x %2x %2x %2x \n" },
    { .value=0x01f50002, .str="PMU3: Preamble search pass=%d anyfail=%d\n" },
    { .value=0x01f60000, .str="PMU: Error: RxEn training preamble not found\n" },
    { .value=0x01f70000, .str="PMU4: Found DQS pre-amble\n" },
    { .value=0x01f80000, .str="PMU4: RxEn aligning to first rising edge of burst\n" },
    { .value=0x01f90001, .str="PMU3: Decreasing RxEn delay by %d fine step to allow full capture of reads\n" },
    { .value=0x01fa0002, .str="PMU1: In rxStrobless_train() csn=%d pstate=%d\n" },
    { .value=0x01fb0000, .str="PMU3: Searching for coarse strobless setting\n" },
    { .value=0x01fc0002, .str="PMU3: present CS %d CS %d\n" },
    { .value=0x01fd0003, .str="PMU1: DoDbi %d doRdDbi %d doWrDBI %d \n" },
    { .value=0x01fe0004, .str="PMU3: Training DIMM %d CSn %d doDBI %d stage %d \n" },
    { .value=0x01ff0000, .str="PMU3:Writing all MRs to fsp 1\n" },
    { .value=0x02000000, .str="PMU4: starting devinit\n" },
    { .value=0x02010000, .str="PMU10:Quickboot mode.\n" },
    { .value=0x02020000, .str="PMU1: Power Down Exit\n" },
    { .value=0x02030000, .str="PMU3: devinit - entered slowmo\n" },
    { .value=0x02040000, .str="PMU1: devinit - !bootfreq_enabled - assert_cke\n" },
    { .value=0x02050000, .str="PMU3: Writing MRs\n" },
    { .value=0x02060003, .str="PMU3: slowmo boot clock divider %d; index = %u, AC Bump Clock Factor = %u\n" },
    { .value=0x02070000, .str="PMU10: Starting RXEN training for all ranks\n" },
    { .value=0x02080000, .str="PMU10: Starting Rx Dig Strobe training for all ranks\n" },
    { .value=0x02090000, .str="PMU10: Starting RXEN training for all ranks\n" },
    { .value=0x020a0000, .str="PMU10: Starting write leveling fine delay training for all ranks\n" },
    { .value=0x020b0000, .str="PMU10: Starting write leveling coarse delay training for all ranks\n" },
    { .value=0x020c0000, .str="PMU10: Starting SI friendly RdDqs training for all ranks\n" },
    { .value=0x020d0000, .str="PMU10: Starting RdDqs training for all ranks\n" },
    { .value=0x020e0000, .str="PMU10: SKipping SI friendly RdDqs training in Strobeless mode\n" },
    { .value=0x020f0000, .str="PMU10: Starting DRAM DCA training for all ranks\n" },
    { .value=0x02100000, .str="PMU10: Starting Rx DCA training for all ranks\n" },
    { .value=0x02110000, .str="PMU10: Skipping Rx DCA training in Strobeless mode\n" },
    { .value=0x02120000, .str="PMU10: Starting DRAM TxDFE training for all ranks\n" },
    { .value=0x02130000, .str="PMU10: Starting WrDq training for all ranks\n" },
    { .value=0x02140000, .str="PMU10: Starting Tx DCA training for all ranks\n" },
    { .value=0x02150000, .str="PMU10: Starting PPT2 Tx training for all ranks\n" },
    { .value=0x02160000, .str="PMU4: pmu_2Dtrain() - PPT2 WECC Training\n" },
    { .value=0x02170000, .str="PMU10: Starting PPT2 Rx training for all ranks\n" },
    { .value=0x02180001, .str="PMU10: Starting MaxRdLat training\nPMU10: TEST trainlane8=%x \n" },
    { .value=0x02190001, .str="PMU Error: Invalid Reserved13 Selected:  0x%x \n" },
    { .value=0x021a0003, .str="PMU10: global_PUBREV:0x%x  csr_PUBREV:0x%x  msgReserved13:0x%x  \n" },
    { .value=0x021b0000, .str="PMU1: Message block contents\n" },
    { .value=0x021c0000, .str="PMU200: ABOUT TO RUN FLAG INSTRUCTION\n" },
    { .value=0x021d0000, .str="PMU200: ABOUT TO TRIGGER DIVIDE BY ZERO TRAP\n" },
    { .value=0x021e0001, .str="PMU200: TRIGGERED DIVIDE BY ZERO TRAP temp2 = %d\n" },
    { .value=0x021f0000, .str="PMU Error: Failed to take halt handler on divide by zero\n" },
    { .value=0x02200000, .str="PMU10: Starting Device init\n" },
    { .value=0x02210001, .str="PMU10: **** Start LPDDR4 Training. PMU Firmware Revision 0x%04x ****\n" },
    { .value=0x02220001, .str="PMU10: **** Start LPDDR5 Training. PMU Firmware Revision 0x%04x ****\n" },
    { .value=0x02230005, .str="PMU10: PUBVAR=%x  PUBREV=%x CUSTPUBREV=%x PHYREV=%x CUSTPHYREV=%x \n" },
    { .value=0x02240000, .str="PMU: Error: Mismatched internal revision between DCCM and ICCM images\n" },
    { .value=0x02250001, .str="PMU10: **** Testchip %d Specific Firmware ****\n" },
    { .value=0x02260000, .str="PMU4: pmu_init() complete\n" },
    { .value=0x02270000, .str="PMU10: Starting CA training for all ranks\n" },
    { .value=0x02280000, .str="PMU10: Running DQS2DQ Oscillator for all ranks\n" },
    { .value=0x02290000, .str="PMU10: Starting LP3\n" },
    { .value=0x022a0001, .str="PMU3: setting dfe to %x \n" },
    { .value=0x022b0000, .str="PMU3: TxDFE training starts\n" },
    { .value=0x022c0002, .str="PMU3: TxDFE eye process for dfe=%x csn=%x\n" },
    { .value=0x022d0004, .str="PMU3: for csn%d ch%d upper(1)/lower(0):%d, best dfe is %x \n" },
    { .value=0x022e0003, .str="PMU: Training failed for cs = %d, ch = %d, upper(1)/lower(0) = %d\n" },
    { .value=0x022f0000, .str="PMU3: TxDFE training ends\n" },
    { .value=0x02300005, .str="PMU3: TXDFE compounded eye: csn%d delay=%d eye_top=%d eye_bot=%d anchor=%d \n" },
    { .value=0x02310001, .str="PMU3: TXDFE returned total_area=%d \n" },
    { .value=0x02320002, .str="PMU1: 1st RxDfe0FifoInfo[%d]= %x \n" },
    { .value=0x02330002, .str="PMU1: 2nd rdLoc[%d]= %x \n" },
    { .value=0x02340002, .str="PMU1: 3rd rdloc+ui[%d]= %x \n" },
    { .value=0x02350000, .str="PMU: ERROR: Wrong strobe mode chosen for lpEnterExitAsyncMode\n" },
    { .value=0x02360005, .str="PMU3: fixRxEnBackOff csn:%d db:%d dn:%d bo:%d dly:%x\n" },
    { .value=0x02370001, .str="PMU3: fixRxEnBackOff dly:%x\n" },
    { .value=0x02380000, .str="PMU3: Entering setupPpt\n" },
    { .value=0x02390000, .str="PMU3: Start lpPopulateHighLowBytes\n" },
    { .value=0x023a0004, .str="PMU3: chan = %u, csn = %u, x8: dev_id = %u, lptr.CaLowByte[chan][csn][dev_id] = %u\n" },
    { .value=0x023b0004, .str="PMU3: chan = %u, csn = %u, x8: dev_id = %u, lptr.CaLowByte[chan][csn][dev_id] = %u\n" },
    { .value=0x023c0004, .str="PMU3: chan = %u, csn = %u, x16: dev_id = %u, lptr.CaLowByte[chan][csn][dev_id] = %u\n" },
    { .value=0x023d0004, .str="PMU3: chan = %u, csn = %u, x16: dev_id = %u, lptr.CaHighByte[chan][csn][dev_id] = %u\n" },
    { .value=0x023e0001, .str="PMU3: Reading MR%u\n" },
    { .value=0x023f0003, .str="PMU3:getDqs2Dq read %x from dbyte %d csn %d\n" },
    { .value=0x02400003, .str="PMU3:getDqs2Dq(2) read %x from dbyte %d csn %d\n" },
    { .value=0x02410002, .str="PMU3: Dbyte %d dqs2dq = %d osc count\n" },
    { .value=0x02420002, .str="PMU4: Dbyte %d dqs2dq = %d/64\n" },
    { .value=0x02430003, .str="PMU3:getDqs2Dq read %x from dbyte %d csn %d\n" },
    { .value=0x02440003, .str="PMU3:getDqs2Dq(2) read %x from dbyte %d csn %d\n" },
    { .value=0x02450002, .str="PMU3: Dbyte %d wck2dqo = %d osc count\n" },
    { .value=0x02460003, .str="PMU4: Dbyte %d wck2dqi = %d/64 wck2dqo = %d/64\n" },
    { .value=0x02470003, .str="PMU3:getDqs2Dq set dqs2dq:%d/64 ui (%d ps) from dbyte %d\n" },
    { .value=0x02480000, .str="PMU4: Enter self refresh\n" },
    { .value=0x02490000, .str="PMU1: Exit self refresh\n" },
    { .value=0x024a0005, .str="PMU1: read_delay: db%d lane%d delays[%2d] = 0x%02x (max 0x%02x)\n" },
    { .value=0x024b0001, .str="PMU5: ID=%d -- db0  db1  db2  db3 --\n" },
    { .value=0x024c0005, .str="PMU5: [%d]:0x %4x %4x %4x %4x \n" },
    { .value=0x024d0003, .str="PMU2: dump delays - pstate=%d dimm=%d csn=%d\n" },
    { .value=0x024e0000, .str="PMU3: Printing Mid-Training Delay Information\n" },
    { .value=0x024f0001, .str="PMU5: CS%d <<KEY>> 0 TrainingCntr <<KEY>> coarse(15:10) fine(9:0)\n" },
    { .value=0x02500001, .str="PMU5: CS%d <<KEY>> 0 RxEnDly, 1 RxClkTDly, 2 RxClkCDly, 3 VrefDAC0, 4 VrefDAC1, 5 VrefDAC2, 6 VrefDAC3 <<KEY>> coarse(10:6) fine(5:0)\n" },
    { .value=0x02510001, .str="PMU5: CS%d <<KEY>> 0 TxDqsDly, 1 TxDqDly, 2 MR14 <<KEY>> coarse(9:6) fine(5:0)\n" },
    { .value=0x02520001, .str="PMU5: CS%d <<KEY>> 0 WckDly, 1 TxDqDly, 2 MR14/MR15, 3 TxDqsDly  <<KEY>> coarse(9:6) fine(5:0)\n" },
    { .value=0x02530002, .str="PMU2: dump MR24 - dimm=%d csn=%d\n" },
    { .value=0x02540000, .str="PMU5: all CS <<KEY>> 0 MR24 <<KEY>>\n" },
    { .value=0x02550000, .str="PMU5: all CS <<KEY>> 0 DFIMRL <<KEY>> Units = DFI clocks\n" },
    { .value=0x02560000, .str="PMU5: all CS <<KEY>> VrefDACs <<KEY>> DAC(6:0)\n" },
    { .value=0x02570000, .str="PMU1: Set DMD in MR13 and wrDBI in MR3 for training\n" },
    { .value=0x02580009, .str="PMU1: sanitize MR 1: 0x%x  2: 0x%x 11: 0x%x, 13: 0x%x 3: 0x%x 16: 0x%x 17: 0x%x 22: 0x%x 24: 0x%x \n" },
    { .value=0x02590000, .str="PMU1: Set DMD in MR13 and wrDBI in MR3 for training\n" },
    { .value=0x025a000c, .str="PMU1: sanitize MR 1: 0x%x MR 2: 0x%x MR11:0x%x MR13: 0x%x MR3: 0x%x MR16: 0x%x MR17: 0x%x MR20: 0x%x MR24: 0x%x MR41:0x%x MR19: 0x%x MR28: 0x%x\n" },
    { .value=0x025b0000, .str="PMU: Error: getMaxRxen() failed to find largest rxen nibble delay\n" },
    { .value=0x025c0003, .str="PMU2: getMaxRxen(): maxDly %d maxTg %d maxNib %d\n" },
    { .value=0x025d0001, .str="PMU4: Calculating CDDs for pstate %d\n" },
    { .value=0x025e0004, .str="PMU3: rxDly[tg%d][db%d] coarse = %d fine = %d\n" },
    { .value=0x025f0004, .str="PMU3: txDly[tg%d][db%d] coarse = %d fine = %d\n" },
    { .value=0x02600003, .str="PMU3: CDD_RR_%d_%d = %d UI\n" },
    { .value=0x02610003, .str="PMU3: CDD_WW_%d_%d = %d fine\n" },
    { .value=0x02620006, .str="PMU4: CDD_RR_%d_%d = %d MEMCLK\nPMU4: CDD_WW_%d_%d = %d MEMCLK\n" },
    { .value=0x02630003, .str="PMU3: CDD_RW_%d_%d = %d fine\n" },
    { .value=0x02640003, .str="PMU3: CDD_WR_%d_%d = %d fine\n" },
    { .value=0x02650006, .str="PMU4: CDD_RW_%d_%d = %d MEMCLK\nPMU4: CDD_WR_%d_%d = %d MEMCLK\n" },
    { .value=0x02660001, .str="PMU3: Strobeless = %d\n" },
    { .value=0x02670001, .str="PMU3: Wecc = %d\n" },
    { .value=0x02680001, .str="PMU3: WckAlwaysOn = %d\n" },
    { .value=0x02690004, .str="PMU3: rxenDly[tg%d][db%d] = %d coarse %d fine\n" },
    { .value=0x026a0005, .str="PMU3: rxdigDly[tg%d][db%d][lane%d] = %d coarse %d fine\n" },
    { .value=0x026b0005, .str="PMU3: txdqDly[tg%d][db%d][lane%d] = %d coarse %d fine\n" },
    { .value=0x026c0004, .str="PMU3: txdqsDly[tg%d][db%d] = %d coarse %d fine\n" },
    { .value=0x026d0003, .str="PMU3: CDD_RR_%d_%d = %d UI\n" },
    { .value=0x026e0003, .str="PMU3: CDD_WW_%d_%d = %d fine\n" },
    { .value=0x026f0006, .str="PMU4: CDD_RR_%d_%d = %d MEMCLK\nPMU4: CDD_WW_%d_%d = %d MEMCLK\n" },
    { .value=0x02700003, .str="PMU3: CDD_RW_%d_%d = %d fine\n" },
    { .value=0x02710003, .str="PMU3: CDD_WR_%d_%d = %d fine\n" },
    { .value=0x02720006, .str="PMU4: CDD_RW_%d_%d = %d MEMCLK\nPMU4: CDD_WR_%d_%d = %d MEMCLK\n" },
    { .value=0x02730001, .str="PMU1: enter_lp3: DEBUG: pllbypass = %d\n" },
    { .value=0x02740001, .str="PMU1: enter_lp3: DEBUG: pllmaxrange = 0x%x\n" },
    { .value=0x02750001, .str="PMU1: enter_lp3: DEBUG: dacval_out = 0x%x\n" },
    { .value=0x02760001, .str="PMU1: enter_lp3: DEBUG: pllctrl3 = 0x%x\n" },
    { .value=0x02770000, .str="PMU3: Loading DRAM with BIOS supplied MR values and entering self refresh prior to exiting PMU code.\n" },
    { .value=0x02780002, .str="PMU1: do background %d mr28 val 0x%x \n" },
    { .value=0x02790006, .str="PMU4: calculated RxClkT2uiDly for dbyte %d coarse  %d fine %d tPhyDQS2DQ: %d select phase %d raw path phase %d\n" },
    { .value=0x027a0004, .str="PMU1: switch_FSP0 MR1 0x%x MR20 0x%x chan %d csn%d\n" },
    { .value=0x027b0002, .str="PMU3: In function save_restore_phy_csrs, num_csrs = %u, save = %u\n" },
    { .value=0x027c0004, .str="PMU1: raw rxClkEstimate for DBYTE%d: 0x%x, 2UIdly: 0x%x, isSecondRun %d\n" },
    { .value=0x027d0004, .str="PMU1: dbyte%d raw txWck Estimate %d ui, txWckDlyFine %d ui, estimate tDqs2dq %d ui \n" },
    { .value=0x027e0001, .str="PMU: Error: Invalid Training CSR %d specified in training.\n" },
    { .value=0x027f0005, .str="PMU1: Results of scan: DB:%u lane %d state:%u, left:%u, right%u\n" },
    { .value=0x02800005, .str="PMU1: delay output Lane %d delay %u delayLeft %u delayRight %u startDelayFine %u\n" },
    { .value=0x02810001, .str="PMU201:t_meas %d\n" },
    { .value=0x02820001, .str="PMU10: vrefTraining  csn%d\n" },
    { .value=0x02830004, .str="PMU4: db%dln%ddfe%d vref offset %3d\n" },
    { .value=0x02840007, .str="PMU4: db%dln%ddfe%d vref offset %3d, cmp %d, err %d, good %d \n" },
    { .value=0x02850001, .str="PMU5: DFE%d DB0 DB1 DB2 DB3 \n" },
    { .value=0x02860005, .str="L%d    %3d %3d %3d %3d \n" },
    { .value=0x02870001, .str="PMU3: got %d for cl in load_wrlvl_acsm\n" },
    { .value=0x02880001, .str="PMU4: fine_wrlvl_iterations = %u\n" },
    { .value=0x02890000, .str="PMU1: Star/Stop Wck toggles \n" },
    { .value=0x028a0002, .str="PMU3: Configure CKR for channel %u, rank %u\n" },
    { .value=0x028b0001, .str="PMU4: fine_wrlvl_iterations = %u\n" },
    { .value=0x028c0001, .str="PMU1: Writing %u to csr_ACSMWckFreqSwTogglePulseDelay register\n" },
    { .value=0x028d0000, .str="PMU3: Power Down DQS receiver\n" },
    { .value=0x028e0000, .str="PMU4: LP5 WrLvl Coarse:  ACSMLowSpeedClock divider was 0, setting it to 1\n" },
    { .value=0x028f0001, .str="PMU4: Programming LP5 coarse write leveling sequence, rcnt = %u\n" },
    { .value=0x02900003, .str="PMU4: now slow nop cntr=%d, fast_tck_cntr=%d, now the fast_tck_offset=%d\n" },
    { .value=0x02910002, .str="PMU4: min Nop is %d, total %d Nop to full the slow ck\n" },
    { .value=0x02920001, .str="PMU4: strb2dq64ths = %u\n" },
    { .value=0x02930004, .str="PMU4: lane = %u, strbFine = %u, txdq_delays[%u] = %u\n" },
    { .value=0x02940003, .str="PMU4: db = %u:: initial coarse = %u, fine = %u \n" },
    { .value=0x02950000, .str="PMU4: Changing coarse to minimum value\n" },
    { .value=0x02960002, .str="PMU4: New: coarse = %u, fine = %u \n" },
    { .value=0x02970003, .str="PMU4: After increase by %u :: coarse = %u, fine = %u \n" },
    { .value=0x02980003, .str="PMU4: After decrease by %u :: coarse = %u, fine = %u \n" },
    { .value=0x02990004, .str="PMU5: Dbyte%2d, csr 0x%x (coarse: %u, fine: %u)\n" },
    { .value=0x029a0002, .str="PMU5: CSR values of channel %d, rank %d after fine write leveling phase are:\n" },
    { .value=0x029b0001, .str="PMU4: WrLvlTrainOpt is 0x%x\n" },
    { .value=0x029c0000, .str="PMU10: Skipping LP5 WrLvl coarse training\n" },
    { .value=0x029d0002, .str="PMU4: Starting WrLvl Coarse training for channel %u rank %u\n" },
    { .value=0x029e0001, .str="PMU3: ACSMLowSpeedClockDelay = 0x%x\n" },
    { .value=0x029f0001, .str="PMU3: ACSMLowSpeedClockEnable = 0x%x\n" },
    { .value=0x02a00000, .str="PMU4: Coarse write leveling hardware search starts\n" },
    { .value=0x02a10002, .str="PMU4: Coarse write leveling value for DBYTE %u found, TxWckDly=0x%04x\n" },
    { .value=0x02a20000, .str="PMU4: Setting first_iteration_sampled_ck_high\n" },
    { .value=0x02a30003, .str="PMU4: Coarse write leveling dbyte%2d fails for coarse: %u, fine =%u\n" },
    { .value=0x02a40000, .str="PMU4: Coarse write leveling special case\n" },
    { .value=0x02a50003, .str="PMU4: Coarse write leveling special case, dbyte%2d: coarse: %u, fine =%u\n" },
    { .value=0x02a60003, .str="PMU4: Coarse write leveling corner case: DBYTE %u, coarse = %d, TxWckDly=0x%04x\n" },
    { .value=0x02a70003, .str="PMU4: Coarse write leveling dbyte%2d failed even for coarse: %u, fine =%u\n" },
    { .value=0x02a80000, .str="PMU: Error: Failed write leveling coarse\n" },
    { .value=0x02a90000, .str="PMU5: CSR values after coarse write leveling phase are:\n" },
    { .value=0x02aa0003, .str="PMU4: Generating WrLvl fine shmoo with step_size = %u, for channel %u rank %d\n" },
    { .value=0x02ab0001, .str="PMU4: Wck[%d]  " },
    { .value=0x02ac0002, .str="\nUI%02u - UI%02u " },
    { .value=0x02ad0008, .str="%x%x%x%x%x%x%x%x" },
    { .value=0x02ae0000, .str="\n" },
    { .value=0x02af0003, .str="PMU5: Starting WrLvl fine for channel %u rank %d, pstate %d\n" },
    { .value=0x02b00000, .str="PMU4: Doing fine write leveling with large step\n" },
    { .value=0x02b10000, .str="PMU4: Doing fine write leveling with small steps\n" },
    { .value=0x02b20000, .str="PMU4: Exiting write leveling mode\n" },
    { .value=0x02b30003, .str="PMU1: In write_level_coarse() csn=%d dimm=%d pstate %d\n" },
    { .value=0x02b40003, .str="PMU3: left eye edge search db:%d ln:%d dly:0x%x\n" },
    { .value=0x02b50003, .str="PMU3: right eye edge search db:%d ln:%d dly:0x%x\n" },
    { .value=0x02b60005, .str="PMU3: db:%d ln:%d, odly=%u dly=%u, maxdq=%u\n" },
    { .value=0x02b70004, .str="PMU3: eye center db:%d ln:%d dly:0x%x (maxdq:%x)\n" },
    { .value=0x02b80003, .str="PMU3: Wrote to TxDqDly db:%d ln:%d dly:0x%x\n" },
    { .value=0x02b90002, .str="PMU3: Coarse write leveling dbyte%2d is still failing for TxDqsDly=0x%04x\n" },
    { .value=0x02ba0002, .str="PMU4: Coarse write leveling iteration %d saw %d data miscompares across the entire phy\n" },
    { .value=0x02bb0000, .str="PMU: Error: Failed write leveling coarse\n" },
    { .value=0x02bc0001, .str="PMU0: chan: %0d\n" },
    { .value=0x02bd0004, .str="PMU0: CHAN %0x delays_tg[%x][%x]: %0x\n" },
    { .value=0x02be0005, .str="PMU0: MAX_CHAN %x MAX_RANKS %x MAX_DBYTES %x avg %x rank_i: %x \n" },
    { .value=0x02bf0006, .str="PMU4: (Chan %x Rank %x db %x ) : Average = %x Average Coarse = %x, Average Fine = %x\n" },
    { .value=0x02c00007, .str="PMU0: (chan %x rank %x db %x ) : avg= %0x delay_csr_addr= %0x delay_csr_addr+destTg= %0x delay= %0x\n" },
};

static firmware_phy_debug_strings_t ddr_phy_debug_modalix_strings[] = {
    { .strings=&lpddr5_pmu_train_debug[0], .size=ARRAY_SIZE(lpddr5_pmu_train_debug) },
};

int32_t get_ddr_phy_debug_string(uint32_t firmware, uint32_t value, char ** str) {
    int i;
    if(firmware > ARRAY_SIZE(ddr_phy_debug_modalix_strings))
        return -1;
    if(str == NULL)
        return -2;
    for(i = 0; i < ddr_phy_debug_modalix_strings[firmware].size; i++)
        if(value == ddr_phy_debug_modalix_strings[firmware].strings[i].value) {
            *str = &ddr_phy_debug_modalix_strings[firmware].strings[i].str[0];
            return 0;
        }
    return -3;
}
